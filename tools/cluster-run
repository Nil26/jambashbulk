#! /usr/bin/env python2

LEGAL="""\
cluster-run 0.4 - run jobs on many computers
Copyright 2007-2010 Stichting voor Fundamenteel Onderzoek der Materie
Written by Christoph Groth <cwg@falma.de>

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.
"""

import sys, time, os, subprocess, signal

# Configuration
# -t force TTY allocation
# -t *really* force TTY allocation, even though stdin is /dev/null
# -n do not read stdin
SSH = ["ssh", "-n", "-o ConnectTimeout=20", "-o ForwardX11=no"]
LOAD_GRACE = 0.1                # See code.
PING_TIMEOUT = 30               # How long to wait for a ping to finish

NAP_TIME = 1                    # Time to wait if there is noting to do
MIN_WAIT = 10                   # When a machine is busy
MAX_WAIT = 60                   # Ditto
WAIT_GROWTH_FACTOR = 1.2        # Waiting time grows each time by this

# Defaults for command line arguments and options
DEFAULT_MIN_FREE_LOAD = 1
DEFAULT_N_PASSES = 1
DEFAULT_MAX_N_CHILDREN = 10
DEFAULT_REST_TIME = 5

MIN_FREE_LOAD = DEFAULT_MIN_FREE_LOAD
N_PASSES = DEFAULT_N_PASSES
MAX_N_CHILDREN = DEFAULT_MAX_N_CHILDREN
REST_TIME = DEFAULT_REST_TIME
NO_REDIRECT = False

INFINITY = float('inf')

def usage():
    sys.stdout.write("""\
Usage: cluster-run [options] MACHINE [MACHINE...]
Description:
  A list of commands to be executed is read from stdin.  The commands are
  executed via ssh on the remote machines in the same directory as the working
  directory on the local machine (we expect to run on a cluster with a shared
  file system).  Unless the option --no-redirect is used, standard output is
  redirected to a file called DATE_MACHINE.dat and standard error is
  redirected to a file called DATE_MACHINE.err.  The first line of each .dat
  file is generated by cluster-run and has the form
  # Output of <command>
  Empty .err-files are deleted.
Options:
  -c, --max-children=N  Launch maximally N child processes.  Defaults to """ \
+ str(DEFAULT_MAX_N_CHILDREN) + \
""".
  -m N, --min-free=N    Launch jobs only on machines with at least N free CPUs.
  -n, --no-redirect     Do not redirect standard output / error automatically.
  -p N, --passes=N      Run the commands read from stdin N times.  Default is """ \
+ str(DEFAULT_N_PASSES) + \
""".
  -r, --rest=T          Minimum time in seconds between starting jobs on the
                        same machine.  Defaults to """ \
+ str(DEFAULT_REST_TIME) + """.
  -h, --help            Print this message and exit.
  -V, --version         Print information about version, author and license.
Examples:
  cluster-run <commands machine1 machine2 machine3 machine4
  echo a.out | cluster-run -p100 clust{0..9}
""")

def version():
    sys.stdout.write(LEGAL)

def rtfm(s):
    sys.stderr.write("cluster-run: " + s
                     + "\nTry `cluster-run --help' for more information.\n")
    sys.exit(1)

def parse_args():
    import getopt
    global N_PASSES, MAX_N_CHILDREN, REST_TIME, NO_REDIRECT, MACHINE_NAMES
    global MIN_FREE_LOAD

    try:
        opts, remaining_args = getopt.getopt(
            sys.argv[1:], "c:m:np:r:hV",
            ["max-children=", "rest=", "min-free=", "no-redirect",
             "passes=", "help", "version"])
    except getopt.GetoptError, e:
        rtfm(str(e))

    for o, a in opts:
        if o in ("-n", "--no-redirect"):
            NO_REDIRECT = True
        elif o in ("-m", "--min-free"):
            try:
                MIN_FREE_LOAD = float(a)
            except ValueError:
                rtfm('invalid "min-free" argument')
#            if MIN_FREE_LOAD < 1:
#                rtfm('minimum number of free CPUs must be at least 1')
        elif o in ("-c", "--max-children"):
            try:
                MAX_N_CHILDREN = int(a)
            except ValueError:
                rtfm('invalid "max-children" argument')
            if MAX_N_CHILDREN < 1:
                rtfm('maximum number of child processes must be at least 1')
        elif o in ("-r", "--rest"):
            try:
                REST_TIME = float(a)
            except ValueError:
                rtfm('invalid "rest" argument')
            if REST_TIME < 1:
                rtfm('rest time must be at least 1')
        elif o in ("-p", "--passes"):
            try:
                N_PASSES = int(a)
            except ValueError:
                rtfm('invalid "passes" argument')
            if N_PASSES < 0:
                rtfm('number of passes cannot be negative')
        elif o in ("-h", "--help"):
            usage()
            sys.exit()
        elif o in ("-V", "--version"):
            version()
            sys.exit()

    if remaining_args == ["DEFAULT"]:
        remaining_args = ["maris%03i" % i for i in range(25,33) + range(61,68)]
    elif remaining_args == ["ALL"]:
        remaining_args = ["maris%03i" % i for i in range(5,68)]

    if len(remaining_args) < 1:
        rtfm("expecting at least one machine name, use DEFAULT to use the default list")
    MACHINE_NAMES = remaining_args
    print "Using machines: ", " ".join(MACHINE_NAMES)

class Machine:
    def __init__(self, name):
        self.name = name        # Name of machine
        self.free_load = 0      # = max. load (nr. of CPUs) - current load
        self.valid_until = 0    # For the above value
        self.last_wait = 0

    def needs_ping(self):
        return time.time() > self.valid_until

    def is_ready_to_run(self):
        return (time.time() < self.valid_until and
                self.free_load > MIN_FREE_LOAD - LOAD_GRACE)

    def ping(self):
        self.free_load = 0
        self.valid_until = INFINITY
        command = "".join((
                "grep ^processor /proc/cpuinfo | wc -l; ",
                "top -bn1 | tail -n+8 | awk '{sum += $9} END {print sum}'; ",
                "uptime | sed 's/^.*load average: //;s/,.*$//'"))
        end_of_patience = time.time() + PING_TIMEOUT
        try:
            p = subprocess.Popen(SSH + [self.name, command],
                                 stdout=subprocess.PIPE,
                                 stderr=subprocess.PIPE)
        except OSError, e:
            print 'Serious problem: execution of ssh failed:', str(e)
            self.last_wait = MIN_WAIT
            self.valid_until = time.time() + self.last_wait
            yield None
            return
        while time.time() < end_of_patience and p.poll() == None:
            yield None

        if p.returncode == 0:
            outputs = p.communicate()[0].split()
            try:
                if len(outputs) != 3:
                    raise ValueError
                max_load = int(outputs[0])
                instant_load = float(outputs[1]) * 0.01
                avg_load = float(outputs[2])
                self.free_load = max_load - max(instant_load, avg_load)
            except ValueError:
                print 'Unexpected output from the ping commands: ', outputs

        else:
            if p.returncode == None:
                try:
                    os.kill(p.pid, signal.SIGTERM)
                    yield None
                    yield None
                    while p.poll() == None:
                        os.kill(p.pid, signal.SIGKILL)
                        yield None
                        yield None
                except OSError:
                    pass
                if self.last_wait == 0:
                    print self.name, 'did not answer ping until timeout.'
            else:
                if self.last_wait == 0:
                    print self.name, 'unreachable.  ssh returned', \
                        str(p.returncode) + '.'

        if self.free_load > MIN_FREE_LOAD - LOAD_GRACE:
            self.last_wait = 0
            # self.valid_until is infinity
        else:
            self.last_wait = max(WAIT_GROWTH_FACTOR * self.last_wait,
                                 MIN_WAIT)
            self.last_wait = min(self.last_wait, MAX_WAIT)
            self.valid_until = time.time() + self.last_wait

    def run(self, command):
        self.free_load = 0
        self.valid_until = INFINITY
        if NO_REDIRECT:
            print 'running on %s: %s' % (self.name, command)
            cwd = os.getcwd().replace("'", "'\\''")
            to_be_run = "cd '%s'; ( %s ) >/dev/null 2>/dev/null &" % \
                (cwd, command)
        else:
            fname = time.strftime("%Y%m%d-%H%M%S") + '_' + self.name
            print '%s >>%s.dat 2>%s.err' % (command, fname, fname)
            cwd, fname = tuple(
                s.replace("'", "'\\''") for s in (os.getcwd(), fname))
            to_be_run = "".join((
		# Include loc bin folder
		'export PATH="$HOME/bin:$PATH";' 
               # Change into working directory.
                "cd '%s'; " % cwd,
                # Create first line of output file.
                "echo >'%s'.dat \\# Output of '%s'; " % \
                    (fname, command.replace("'", r"'\''")),
                # Run command.
                "(%s; " % command,
                # Delete error logfile if it exists and is empty.
                "test -f '%s'.err -a ! -s '%s'.err && rm '%s'.err) " % \
                    (3 * (fname,)),
                # Redirect output
                ">>'%s'.dat 2>'%s'.err &" % (fname, fname)))

#	print('\n')
#	print(to_be_run.replace("'", "'\\''"))
#	print('\n')

        try:
            p = subprocess.Popen(SSH + [self.name, '/bin/bash', '-c',
                                  "'" + to_be_run.replace("'", "'\\''") + "'"])
        except OSError, e:
            print 'Serious problem: execution of ssh failed:', str(e)
            self.last_wait = MIN_WAIT
            self.valid_until = time.time() + self.last_wait
            yield command       # "Give `command' back"
            return
        while p.poll() == None:
            yield None

        if p.returncode == 0:
            self.valid_until = time.time() + REST_TIME
        else:
            print self.name, ' unreachable.  ssh returned ', \
                str(p.returncode) + '.'
            self.last_wait = MIN_WAIT
            self.valid_until = time.time() + self.last_wait
            yield command       # "Give `command' back"

def schedule(machines, commands):
    global NAP_TIME
    interrupts = 0
    sleepy = True
    did_something = True
    old_remaining_number = len(commands)
    running = []
    while commands or running:
        try:
            did_something = False
            if len(running) < MAX_N_CHILDREN and len(commands) > 0:
                # Run.
                for machine in machines:
                    if len(running) >= MAX_N_CHILDREN or len(commands) == 0:
                        break
                    if machine.is_ready_to_run():
                        running.append(machine.run(commands.pop()))
                        did_something = True
                        sleepy = False

                # Explore.
                for machine in sorted(machines, key=lambda x: x.valid_until):
                    if len(running) >= MAX_N_CHILDREN:
                        break
                    if machine.needs_ping():
                        running.append(machine.ping())
                        did_something = True

            if not did_something:
                if not sleepy:
                    rem = len(commands)
                    if rem <= old_remaining_number - 10:
                        print len(commands), 'remaining.'
                        old_remaining_number = rem
                sleepy = True
                time.sleep(NAP_TIME)

            # Give control once to all children coroutines.
            to_be_removed = []
            for i, child in enumerate(running):
                try:
                    msg = child.next()
                    if msg != None:
                        # This means that running this command has failed.
                        commands.append(msg)
                        child.next() # Will raise StopIteration.
                except StopIteration:
                    to_be_removed.append(i)
            to_be_removed.sort(reverse=True)
            for i in to_be_removed:
                del running[i]

        except KeyboardInterrupt:
            if interrupts > 0:
                raise

            interrupts += 1
            fname = "commands_" + time.strftime("%Y%m%d-%H%M%S")
            print "\n\nReceived interrupt, dumping command list to %s..." % fname
            commands.reverse()
            open(fname, 'w').write('\n'.join(commands) + "\n")
            commands = []
            print "\n" + "-"*40
            print "You can continue this run with: $ " + " ".join(sys.argv) + " < %s" % fname
            print "-" * 40 + "\n"
            print "Waiting for processes to finish... (press ^C again to stop)"

            NAP_TIME = 0.01

def main():
    parse_args()
    machines = [Machine(name) for name in MACHINE_NAMES]
    commands = [line.strip() for line in sys.stdin]
    commands.reverse()
    commands *= N_PASSES
    schedule(machines, commands)

if __name__ == '__main__':
    main()
